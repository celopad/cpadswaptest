{"ast":null,"code":"import { JSBI, Token, TokenAmount } from '@ubeswap/sdk';\nimport { UBE } from 'constants/tokens';\nimport { useMemo } from 'react';\nimport ERC20_INTERFACE from '../../constants/abis/erc20';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useAllTokens } from '../../hooks/Tokens';\nimport { isAddress } from '../../utils';\nimport { useMultipleContractSingleData } from '../multicall/hooks';\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\n\nexport function useTokenBalancesWithLoadingIndicator(address, tokens) {\n  const validatedTokens = useMemo(() => {\n    var _tokens$filter;\n\n    return (_tokens$filter = tokens === null || tokens === void 0 ? void 0 : tokens.filter(t => isAddress(t === null || t === void 0 ? void 0 : t.address) !== false)) !== null && _tokens$filter !== void 0 ? _tokens$filter : [];\n  }, [tokens]);\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map(vt => vt.address), [validatedTokens]);\n  const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20_INTERFACE, 'balanceOf', [address]);\n  const anyLoading = useMemo(() => balances.some(callState => callState.loading), [balances]);\n  return [useMemo(() => address && validatedTokens.length > 0 ? validatedTokens.reduce((memo, token, i) => {\n    var _balances$i, _balances$i$result;\n\n    const value = balances === null || balances === void 0 ? void 0 : (_balances$i = balances[i]) === null || _balances$i === void 0 ? void 0 : (_balances$i$result = _balances$i.result) === null || _balances$i$result === void 0 ? void 0 : _balances$i$result[0];\n    const amount = value ? JSBI.BigInt(value.toString()) : undefined;\n\n    if (amount) {\n      memo[token.address] = new TokenAmount(token, amount);\n    }\n\n    return memo;\n  }, {}) : {}, [address, validatedTokens, balances]), anyLoading];\n}\nexport function useTokenBalances(address, tokens) {\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0];\n} // get the balance for a single token/account combo\n\nexport function useTokenBalance(account, token) {\n  const tokenBalances = useTokenBalances(account, [token]);\n  if (!token) return undefined;\n  return tokenBalances[token.address];\n}\nexport function useCurrencyBalances(account, currencies) {\n  const tokens = useMemo(() => {\n    var _currencies$filter;\n\n    return (_currencies$filter = currencies === null || currencies === void 0 ? void 0 : currencies.filter(currency => currency instanceof Token)) !== null && _currencies$filter !== void 0 ? _currencies$filter : [];\n  }, [currencies]);\n  const tokenBalances = useTokenBalances(account, tokens);\n  return useMemo(() => {\n    var _currencies$map;\n\n    return (_currencies$map = currencies === null || currencies === void 0 ? void 0 : currencies.map(currency => {\n      if (!account || !currency) return undefined;\n      if (currency instanceof Token) return tokenBalances[currency.address];\n      return undefined;\n    })) !== null && _currencies$map !== void 0 ? _currencies$map : [];\n  }, [account, currencies, tokenBalances]);\n}\nexport function useCurrencyBalance(account, currency) {\n  return useCurrencyBalances(account, [currency])[0];\n} // mimics useAllBalances\n\nexport function useAllTokenBalances() {\n  const {\n    account\n  } = useActiveWeb3React();\n  const allTokens = useAllTokens();\n  const allTokensArray = useMemo(() => Object.values(allTokens !== null && allTokens !== void 0 ? allTokens : {}), [allTokens]);\n  const balances = useTokenBalances(account !== null && account !== void 0 ? account : undefined, allTokensArray);\n  return balances !== null && balances !== void 0 ? balances : {};\n} // get the total owned, unclaimed, and unharvested UNI for account\n\nexport function useAggregateUniBalance() {\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React();\n  const uni = chainId ? UBE[chainId] : undefined;\n  const uniBalance = useTokenBalance(account !== null && account !== void 0 ? account : undefined, uni);\n  if (!uni) return undefined;\n  return uniBalance;\n}","map":{"version":3,"sources":["/Users/khoiplus/Desktop/celopad/cpadswaptest/src/state/wallet/hooks.ts"],"names":["JSBI","Token","TokenAmount","UBE","useMemo","ERC20_INTERFACE","useActiveWeb3React","useAllTokens","isAddress","useMultipleContractSingleData","useTokenBalancesWithLoadingIndicator","address","tokens","validatedTokens","filter","t","validatedTokenAddresses","map","vt","balances","anyLoading","some","callState","loading","length","reduce","memo","token","i","value","result","amount","BigInt","toString","undefined","useTokenBalances","useTokenBalance","account","tokenBalances","useCurrencyBalances","currencies","currency","useCurrencyBalance","useAllTokenBalances","allTokens","allTokensArray","Object","values","useAggregateUniBalance","chainId","uni","uniBalance"],"mappings":"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","sourcesContent":["import { JSBI, Token, TokenAmount } from '@ubeswap/sdk'\nimport { UBE } from 'constants/tokens'\nimport { useMemo } from 'react'\nimport ERC20_INTERFACE from '../../constants/abis/erc20'\nimport { useActiveWeb3React } from '../../hooks'\nimport { useAllTokens } from '../../hooks/Tokens'\nimport { isAddress } from '../../utils'\nimport { useMultipleContractSingleData } from '../multicall/hooks'\n\n/**\n * Returns a map of token addresses to their eventually consistent token balances for a single account.\n */\nexport function useTokenBalancesWithLoadingIndicator(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): [{ [tokenAddress: string]: TokenAmount | undefined }, boolean] {\n  const validatedTokens: Token[] = useMemo(\n    () => tokens?.filter((t?: Token): t is Token => isAddress(t?.address) !== false) ?? [],\n    [tokens]\n  )\n\n  const validatedTokenAddresses = useMemo(() => validatedTokens.map(vt => vt.address), [validatedTokens])\n\n  const balances = useMultipleContractSingleData(validatedTokenAddresses, ERC20_INTERFACE, 'balanceOf', [address])\n\n  const anyLoading: boolean = useMemo(() => balances.some(callState => callState.loading), [balances])\n\n  return [\n    useMemo(\n      () =>\n        address && validatedTokens.length > 0\n          ? validatedTokens.reduce<{ [tokenAddress: string]: TokenAmount | undefined }>((memo, token, i) => {\n              const value = balances?.[i]?.result?.[0]\n              const amount = value ? JSBI.BigInt(value.toString()) : undefined\n              if (amount) {\n                memo[token.address] = new TokenAmount(token, amount)\n              }\n              return memo\n            }, {})\n          : {},\n      [address, validatedTokens, balances]\n    ),\n    anyLoading\n  ]\n}\n\nexport function useTokenBalances(\n  address?: string,\n  tokens?: (Token | undefined)[]\n): { [tokenAddress: string]: TokenAmount | undefined } {\n  return useTokenBalancesWithLoadingIndicator(address, tokens)[0]\n}\n\n// get the balance for a single token/account combo\nexport function useTokenBalance(account?: string, token?: Token): TokenAmount | undefined {\n  const tokenBalances = useTokenBalances(account, [token])\n  if (!token) return undefined\n  return tokenBalances[token.address]\n}\n\nexport function useCurrencyBalances(account?: string, currencies?: (Token | undefined)[]): (TokenAmount | undefined)[] {\n  const tokens = useMemo(() => currencies?.filter((currency): currency is Token => currency instanceof Token) ?? [], [\n    currencies\n  ])\n\n  const tokenBalances = useTokenBalances(account, tokens)\n\n  return useMemo(\n    () =>\n      currencies?.map(currency => {\n        if (!account || !currency) return undefined\n        if (currency instanceof Token) return tokenBalances[currency.address]\n        return undefined\n      }) ?? [],\n    [account, currencies, tokenBalances]\n  )\n}\n\nexport function useCurrencyBalance(account?: string, currency?: Token): TokenAmount | undefined {\n  return useCurrencyBalances(account, [currency])[0]\n}\n\n// mimics useAllBalances\nexport function useAllTokenBalances(): { [tokenAddress: string]: TokenAmount | undefined } {\n  const { account } = useActiveWeb3React()\n  const allTokens = useAllTokens()\n  const allTokensArray = useMemo(() => Object.values(allTokens ?? {}), [allTokens])\n  const balances = useTokenBalances(account ?? undefined, allTokensArray)\n  return balances ?? {}\n}\n\n// get the total owned, unclaimed, and unharvested UNI for account\nexport function useAggregateUniBalance(): TokenAmount | undefined {\n  const { account, chainId } = useActiveWeb3React()\n\n  const uni = chainId ? UBE[chainId] : undefined\n\n  const uniBalance: TokenAmount | undefined = useTokenBalance(account ?? undefined, uni)\n\n  if (!uni) return undefined\n\n  return uniBalance\n}\n"]},"metadata":{},"sourceType":"module"}