{"ast":null,"code":"import { newKit } from '@celo/contractkit';\nimport { ChainId, CHAIN_INFO } from '@ubeswap/sdk';\nimport { AbstractConnector } from '@web3-react/abstract-connector';\nimport { NETWORK_CHAIN_ID } from 'connectors';\nimport invariant from 'tiny-invariant';\n\nclass RequestError extends Error {\n  constructor(message, code, data) {\n    super(message);\n    this.code = code;\n    this.data = data;\n  }\n\n}\n\nexport class MiniRpcProvider {\n  constructor(chainId, batchWaitTimeMs) {\n    this.isMetaMask = false;\n    this.chainId = void 0;\n    this.url = void 0;\n    this.host = void 0;\n    this.path = void 0;\n    this.batchWaitTimeMs = void 0;\n    this.kit = void 0;\n    this.nextId = 1;\n    this.batchTimeoutId = null;\n    this.batch = [];\n\n    this.clearBatch = async () => {\n      console.debug('Clearing batch', this.batch);\n      const batch = this.batch;\n      this.batch = [];\n      this.batchTimeoutId = null;\n      let response;\n\n      try {\n        response = await fetch(this.url, {\n          method: 'POST',\n          headers: {\n            'content-type': 'application/json',\n            accept: 'application/json'\n          },\n          body: JSON.stringify(batch.map(item => item.request))\n        });\n      } catch (error) {\n        batch.forEach(({\n          reject\n        }) => reject(new Error('Failed to send batch call')));\n        return;\n      }\n\n      if (!response.ok) {\n        batch.forEach(({\n          reject\n        }) => reject(new RequestError(`${response.status}: ${response.statusText}`, -32000)));\n        return;\n      }\n\n      let json;\n\n      try {\n        json = await response.json();\n      } catch (error) {\n        batch.forEach(({\n          reject\n        }) => reject(new Error('Failed to parse JSON response')));\n        return;\n      }\n\n      const byKey = batch.reduce((memo, current) => {\n        memo[current.request.id] = current;\n        return memo;\n      }, {});\n\n      for (const result of json) {\n        const {\n          resolve,\n          reject,\n          request: {\n            method\n          }\n        } = byKey[result.id];\n\n        if (resolve && reject) {\n          if ('error' in result) {\n            var _result$error, _result$error2, _result$error3;\n\n            reject(new RequestError(result === null || result === void 0 ? void 0 : (_result$error = result.error) === null || _result$error === void 0 ? void 0 : _result$error.message, result === null || result === void 0 ? void 0 : (_result$error2 = result.error) === null || _result$error2 === void 0 ? void 0 : _result$error2.code, result === null || result === void 0 ? void 0 : (_result$error3 = result.error) === null || _result$error3 === void 0 ? void 0 : _result$error3.data));\n          } else if ('result' in result) {\n            resolve(result.result);\n          } else {\n            reject(new RequestError(`Received unexpected JSON-RPC response to ${method} request.`, -32000, result));\n          }\n        }\n      }\n    };\n\n    this.sendAsync = (request, callback) => {\n      this.request(request.method, request.params).then(result => callback(null, {\n        jsonrpc: '2.0',\n        id: request.id,\n        result\n      })).catch(error => callback(error, null));\n    };\n\n    this.request = async (method, params) => {\n      var _this$batchTimeoutId;\n\n      if (typeof method !== 'string') {\n        return this.request(method.method, method.params);\n      }\n\n      if (method === 'eth_chainId') {\n        return `0x${this.chainId.toString(16)}`;\n      }\n\n      const promise = new Promise((resolve, reject) => {\n        this.batch.push({\n          request: {\n            jsonrpc: '2.0',\n            id: this.nextId++,\n            method,\n            params\n          },\n          resolve,\n          reject\n        });\n      });\n      this.batchTimeoutId = (_this$batchTimeoutId = this.batchTimeoutId) !== null && _this$batchTimeoutId !== void 0 ? _this$batchTimeoutId : setTimeout(this.clearBatch, this.batchWaitTimeMs);\n      return promise;\n    };\n\n    this.chainId = chainId;\n    const url = this.url = CHAIN_INFO[chainId].fornoURL;\n    const parsed = new URL(url);\n    this.host = parsed.host;\n    this.path = parsed.pathname; // how long to wait to batch calls\n\n    this.batchWaitTimeMs = batchWaitTimeMs !== null && batchWaitTimeMs !== void 0 ? batchWaitTimeMs : 50;\n    this.kit = newKit(url);\n  }\n\n}\nexport class NetworkConnector extends AbstractConnector {\n  constructor({\n    defaultChainId\n  }) {\n    invariant(defaultChainId, 'defaultChainId is a required argument');\n    super({\n      supportedChainIds: Object.keys(CHAIN_INFO).map(k => Number(k))\n    });\n    this.providers = void 0;\n    this.currentChainId = void 0;\n    this.currentChainId = defaultChainId !== null && defaultChainId !== void 0 ? defaultChainId : NETWORK_CHAIN_ID;\n    this.providers = {\n      [ChainId.MAINNET]: new MiniRpcProvider(ChainId.MAINNET),\n      [ChainId.ALFAJORES]: new MiniRpcProvider(ChainId.ALFAJORES),\n      [ChainId.BAKLAVA]: new MiniRpcProvider(ChainId.BAKLAVA)\n    };\n  }\n\n  get provider() {\n    return this.providers[this.currentChainId];\n  }\n\n  async activate() {\n    return {\n      provider: this.providers[this.currentChainId],\n      chainId: this.currentChainId,\n      account: null\n    };\n  }\n\n  async getProvider() {\n    return this.providers[this.currentChainId];\n  }\n\n  async getChainId() {\n    return this.currentChainId;\n  }\n\n  async getAccount() {\n    return null;\n  }\n\n  deactivate() {\n    return;\n  }\n\n}","map":{"version":3,"sources":["/Users/khoiplus/Desktop/celopad/cpadswaptest/src/connectors/NetworkConnector.ts"],"names":["newKit","ChainId","CHAIN_INFO","AbstractConnector","NETWORK_CHAIN_ID","invariant","RequestError","Error","constructor","message","code","data","MiniRpcProvider","chainId","batchWaitTimeMs","isMetaMask","url","host","path","kit","nextId","batchTimeoutId","batch","clearBatch","console","debug","response","fetch","method","headers","accept","body","JSON","stringify","map","item","request","error","forEach","reject","ok","status","statusText","json","byKey","reduce","memo","current","id","result","resolve","sendAsync","callback","params","then","jsonrpc","catch","toString","promise","Promise","push","setTimeout","fornoURL","parsed","URL","pathname","NetworkConnector","defaultChainId","supportedChainIds","Object","keys","k","Number","providers","currentChainId","MAINNET","ALFAJORES","BAKLAVA","provider","activate","account","getProvider","getChainId","getAccount","deactivate"],"mappings":"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","sourcesContent":["import { ContractKit, newKit } from '@celo/contractkit'\nimport { ChainId, CHAIN_INFO } from '@ubeswap/sdk'\nimport { AbstractConnector } from '@web3-react/abstract-connector'\nimport { ConnectorUpdate } from '@web3-react/types'\nimport { NETWORK_CHAIN_ID } from 'connectors'\nimport invariant from 'tiny-invariant'\n\nexport interface NetworkConnectorArguments {\n  defaultChainId?: ChainId\n}\n\n// taken from ethers.js, compatible interface with web3 provider\ntype AsyncSendable = {\n  isMetaMask?: boolean\n  host?: string\n  path?: string\n  sendAsync?: (request: any, callback: (error: any, response: any) => void) => void\n  send?: (request: any, callback: (error: any, response: any) => void) => void\n}\n\nclass RequestError extends Error {\n  constructor(message: string, public code: number, public data?: unknown) {\n    super(message)\n  }\n}\n\ninterface BatchItem {\n  request: { jsonrpc: '2.0'; id: number; method: string; params: unknown }\n  resolve: (result: any) => void\n  reject: (error: Error) => void\n}\n\nexport class MiniRpcProvider implements AsyncSendable {\n  public readonly isMetaMask: false = false\n  public readonly chainId: ChainId\n  public readonly url: string\n  public readonly host: string\n  public readonly path: string\n  public readonly batchWaitTimeMs: number\n  public readonly kit: ContractKit\n\n  private nextId = 1\n  private batchTimeoutId: ReturnType<typeof setTimeout> | null = null\n  private batch: BatchItem[] = []\n\n  constructor(chainId: ChainId, batchWaitTimeMs?: number) {\n    this.chainId = chainId\n    const url = (this.url = CHAIN_INFO[chainId].fornoURL)\n    const parsed = new URL(url)\n    this.host = parsed.host\n    this.path = parsed.pathname\n    // how long to wait to batch calls\n    this.batchWaitTimeMs = batchWaitTimeMs ?? 50\n    this.kit = newKit(url)\n  }\n\n  public readonly clearBatch = async () => {\n    console.debug('Clearing batch', this.batch)\n    const batch = this.batch\n    this.batch = []\n    this.batchTimeoutId = null\n\n    let response: Response\n    try {\n      response = await fetch(this.url, {\n        method: 'POST',\n        headers: { 'content-type': 'application/json', accept: 'application/json' },\n        body: JSON.stringify(batch.map(item => item.request))\n      })\n    } catch (error) {\n      batch.forEach(({ reject }) => reject(new Error('Failed to send batch call')))\n      return\n    }\n\n    if (!response.ok) {\n      batch.forEach(({ reject }) => reject(new RequestError(`${response.status}: ${response.statusText}`, -32000)))\n      return\n    }\n\n    let json\n    try {\n      json = await response.json()\n    } catch (error) {\n      batch.forEach(({ reject }) => reject(new Error('Failed to parse JSON response')))\n      return\n    }\n    const byKey = batch.reduce<{ [id: number]: BatchItem }>((memo, current) => {\n      memo[current.request.id] = current\n      return memo\n    }, {})\n    for (const result of json) {\n      const {\n        resolve,\n        reject,\n        request: { method }\n      } = byKey[result.id]\n      if (resolve && reject) {\n        if ('error' in result) {\n          reject(new RequestError(result?.error?.message, result?.error?.code, result?.error?.data))\n        } else if ('result' in result) {\n          resolve(result.result)\n        } else {\n          reject(new RequestError(`Received unexpected JSON-RPC response to ${method} request.`, -32000, result))\n        }\n      }\n    }\n  }\n\n  public readonly sendAsync = (\n    request: { jsonrpc: '2.0'; id: number | string | null; method: string; params?: unknown[] | object },\n    callback: (error: any, response: any) => void\n  ): void => {\n    this.request(request.method, request.params)\n      .then(result => callback(null, { jsonrpc: '2.0', id: request.id, result }))\n      .catch(error => callback(error, null))\n  }\n\n  public readonly request = async (\n    method: string | { method: string; params: unknown[] },\n    params?: unknown[] | object\n  ): Promise<unknown> => {\n    if (typeof method !== 'string') {\n      return this.request(method.method, method.params)\n    }\n    if (method === 'eth_chainId') {\n      return `0x${this.chainId.toString(16)}`\n    }\n    const promise = new Promise((resolve, reject) => {\n      this.batch.push({\n        request: {\n          jsonrpc: '2.0',\n          id: this.nextId++,\n          method,\n          params\n        },\n        resolve,\n        reject\n      })\n    })\n    this.batchTimeoutId = this.batchTimeoutId ?? setTimeout(this.clearBatch, this.batchWaitTimeMs)\n    return promise\n  }\n}\n\nexport class NetworkConnector extends AbstractConnector {\n  private readonly providers: { [chainId in ChainId]: MiniRpcProvider }\n  currentChainId: ChainId\n\n  constructor({ defaultChainId }: NetworkConnectorArguments) {\n    invariant(defaultChainId, 'defaultChainId is a required argument')\n    super({ supportedChainIds: Object.keys(CHAIN_INFO).map((k): number => Number(k)) })\n\n    this.currentChainId = defaultChainId ?? NETWORK_CHAIN_ID\n    this.providers = {\n      [ChainId.MAINNET]: new MiniRpcProvider(ChainId.MAINNET),\n      [ChainId.ALFAJORES]: new MiniRpcProvider(ChainId.ALFAJORES),\n      [ChainId.BAKLAVA]: new MiniRpcProvider(ChainId.BAKLAVA)\n    }\n  }\n\n  public get provider(): MiniRpcProvider | null {\n    return this.providers[this.currentChainId]\n  }\n\n  public async activate(): Promise<ConnectorUpdate> {\n    return { provider: this.providers[this.currentChainId], chainId: this.currentChainId, account: null }\n  }\n\n  public async getProvider(): Promise<MiniRpcProvider | null> {\n    return this.providers[this.currentChainId]\n  }\n\n  public async getChainId(): Promise<number> {\n    return this.currentChainId\n  }\n\n  public async getAccount(): Promise<string | null> {\n    return null\n  }\n\n  public deactivate() {\n    return\n  }\n}\n"]},"metadata":{},"sourceType":"module"}