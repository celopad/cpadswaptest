{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar address_1 = require(\"@celo/utils/lib/address\");\n\nvar io_1 = require(\"@celo/utils/lib/io\");\n\nvar Either_1 = require(\"fp-ts/lib/Either\");\n\nvar t = __importStar(require(\"io-ts\"));\n\nvar types_1 = require(\"./types\"); // Provide the type minus the validation that the public key and address are derived from the same private key\n\n\nexports.AccountClaimTypeH = t.type({\n  type: t.literal(types_1.ClaimTypes.ACCOUNT),\n  timestamp: types_1.TimestampType,\n  address: io_1.AddressType,\n  // io-ts way of defining optional key-value pair\n  publicKey: t.union([t.undefined, io_1.PublicKeyType])\n});\nexports.AccountClaimType = new t.Type('AccountClaimType', exports.AccountClaimTypeH.is, function (unknownValue, context) {\n  return Either_1.either.chain(exports.AccountClaimTypeH.validate(unknownValue, context), function (claim) {\n    if (claim.publicKey === undefined) {\n      return t.success(claim);\n    }\n\n    var derivedAddress = address_1.publicKeyToAddress(claim.publicKey);\n    return derivedAddress === claim.address ? t.success(claim) : t.failure(claim, context, 'public key did not match the address in the claim');\n  });\n}, function (x) {\n  return x;\n});\n\nexports.createAccountClaim = function (address, publicKey) {\n  var claim = {\n    timestamp: types_1.now(),\n    type: types_1.ClaimTypes.ACCOUNT,\n    address: address,\n    publicKey: publicKey\n  };\n  var parsedClaim = exports.AccountClaimType.decode(claim);\n\n  if (Either_1.isLeft(parsedClaim)) {\n    throw new Error(\"A valid claim could not be created\");\n  }\n\n  return parsedClaim.right;\n};","map":{"version":3,"sources":["../../../src/identity/claims/account.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,IAAA,SAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;;AACA,IAAA,IAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,IAAA,CAAA,GAAA,YAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA,C,CAEA;;;AACa,OAAA,CAAA,iBAAA,GAAoB,CAAC,CAAC,IAAF,CAAO;AACtC,EAAA,IAAI,EAAE,CAAC,CAAC,OAAF,CAAU,OAAA,CAAA,UAAA,CAAW,OAArB,CADgC;AAEtC,EAAA,SAAS,EAAE,OAAA,CAAA,aAF2B;AAGtC,EAAA,OAAO,EAAE,IAAA,CAAA,WAH6B;AAItC;AACA,EAAA,SAAS,EAAE,CAAC,CAAC,KAAF,CAAQ,CAAC,CAAC,CAAC,SAAH,EAAc,IAAA,CAAA,aAAd,CAAR;AAL2B,CAAP,CAApB;AAQA,OAAA,CAAA,gBAAA,GAAmB,IAAI,CAAC,CAAC,IAAN,CAC9B,kBAD8B,EAE9B,OAAA,CAAA,iBAAA,CAAkB,EAFY,EAG9B,UAAC,YAAD,EAAe,OAAf,EAAsB;AACpB,SAAA,QAAA,CAAA,MAAA,CAAO,KAAP,CAAa,OAAA,CAAA,iBAAA,CAAkB,QAAlB,CAA2B,YAA3B,EAAyC,OAAzC,CAAb,EAAgE,UAAC,KAAD,EAAM;AACpE,QAAI,KAAK,CAAC,SAAN,KAAoB,SAAxB,EAAmC;AACjC,aAAO,CAAC,CAAC,OAAF,CAAU,KAAV,CAAP;AACD;;AACD,QAAM,cAAc,GAAG,SAAA,CAAA,kBAAA,CAAmB,KAAK,CAAC,SAAzB,CAAvB;AACA,WAAO,cAAc,KAAK,KAAK,CAAC,OAAzB,GACH,CAAC,CAAC,OAAF,CAAU,KAAV,CADG,GAEH,CAAC,CAAC,OAAF,CAAU,KAAV,EAAiB,OAAjB,EAA0B,mDAA1B,CAFJ;AAGD,GARD,CAAA;AAQE,CAZ0B,EAa9B,UAAC,CAAD,EAAE;AAAK,SAAA,CAAA;AAAC,CAbsB,CAAnB;;AAkBA,OAAA,CAAA,kBAAA,GAAqB,UAAC,OAAD,EAAkB,SAAlB,EAAoC;AACpE,MAAM,KAAK,GAAG;AACZ,IAAA,SAAS,EAAE,OAAA,CAAA,GAAA,EADC;AAEZ,IAAA,IAAI,EAAE,OAAA,CAAA,UAAA,CAAW,OAFL;AAGZ,IAAA,OAAO,EAAA,OAHK;AAIZ,IAAA,SAAS,EAAA;AAJG,GAAd;AAOA,MAAM,WAAW,GAAG,OAAA,CAAA,gBAAA,CAAiB,MAAjB,CAAwB,KAAxB,CAApB;;AAEA,MAAI,QAAA,CAAA,MAAA,CAAO,WAAP,CAAJ,EAAyB;AACvB,UAAM,IAAI,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,SAAO,WAAW,CAAC,KAAnB;AACD,CAfY","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar address_1 = require(\"@celo/utils/lib/address\");\nvar io_1 = require(\"@celo/utils/lib/io\");\nvar Either_1 = require(\"fp-ts/lib/Either\");\nvar t = __importStar(require(\"io-ts\"));\nvar types_1 = require(\"./types\");\n// Provide the type minus the validation that the public key and address are derived from the same private key\nexports.AccountClaimTypeH = t.type({\n    type: t.literal(types_1.ClaimTypes.ACCOUNT),\n    timestamp: types_1.TimestampType,\n    address: io_1.AddressType,\n    // io-ts way of defining optional key-value pair\n    publicKey: t.union([t.undefined, io_1.PublicKeyType]),\n});\nexports.AccountClaimType = new t.Type('AccountClaimType', exports.AccountClaimTypeH.is, function (unknownValue, context) {\n    return Either_1.either.chain(exports.AccountClaimTypeH.validate(unknownValue, context), function (claim) {\n        if (claim.publicKey === undefined) {\n            return t.success(claim);\n        }\n        var derivedAddress = address_1.publicKeyToAddress(claim.publicKey);\n        return derivedAddress === claim.address\n            ? t.success(claim)\n            : t.failure(claim, context, 'public key did not match the address in the claim');\n    });\n}, function (x) { return x; });\nexports.createAccountClaim = function (address, publicKey) {\n    var claim = {\n        timestamp: types_1.now(),\n        type: types_1.ClaimTypes.ACCOUNT,\n        address: address,\n        publicKey: publicKey,\n    };\n    var parsedClaim = exports.AccountClaimType.decode(claim);\n    if (Either_1.isLeft(parsedClaim)) {\n        throw new Error(\"A valid claim could not be created\");\n    }\n    return parsedClaim.right;\n};\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"script"}