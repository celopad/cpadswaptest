{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar address_1 = require(\"@celo/base/lib/address\");\n\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nvar Web3Utils = __importStar(require(\"web3-utils\")); // Exports moved to @celo/base, forwarding them\n// here for backwards compatibility\n\n\nvar address_2 = require(\"@celo/base/lib/address\");\n\nexports.bufferToHex = address_2.bufferToHex;\nexports.ensureLeading0x = address_2.ensureLeading0x;\nexports.eqAddress = address_2.eqAddress;\nexports.findAddressIndex = address_2.findAddressIndex;\nexports.getAddressChunks = address_2.getAddressChunks;\nexports.hexToBuffer = address_2.hexToBuffer;\nexports.isHexString = address_2.isHexString;\nexports.mapAddressListDataOnto = address_2.mapAddressListDataOnto;\nexports.mapAddressListOnto = address_2.mapAddressListOnto;\nexports.normalizeAddress = address_2.normalizeAddress;\nexports.normalizeAddressWith0x = address_2.normalizeAddressWith0x;\nexports.NULL_ADDRESS = address_2.NULL_ADDRESS;\nexports.trimLeading0x = address_2.trimLeading0x;\n\nvar ethereumjs_util_2 = require(\"ethereumjs-util\");\n\nexports.isValidChecksumAddress = ethereumjs_util_2.isValidChecksumAddress;\nexports.toChecksumAddress = ethereumjs_util_2.toChecksumAddress;\n\nexports.privateKeyToAddress = function (privateKey) {\n  return ethereumjs_util_1.toChecksumAddress(address_1.ensureLeading0x(ethereumjs_util_1.privateToAddress(address_1.hexToBuffer(privateKey)).toString('hex')));\n};\n\nexports.privateKeyToPublicKey = function (privateKey) {\n  return ethereumjs_util_1.toChecksumAddress(address_1.ensureLeading0x(ethereumjs_util_1.privateToPublic(address_1.hexToBuffer(privateKey)).toString('hex')));\n};\n\nexports.publicKeyToAddress = function (publicKey) {\n  return ethereumjs_util_1.toChecksumAddress(address_1.ensureLeading0x(ethereumjs_util_1.pubToAddress(ethereumjs_util_1.toBuffer(address_1.ensureLeading0x(publicKey)), true).toString('hex')));\n};\n\nexports.isValidPrivateKey = function (privateKey) {\n  return privateKey.startsWith('0x') && ethereumjs_util_1.isValidPrivate(address_1.hexToBuffer(privateKey));\n};\n\nexports.isValidAddress = function (input) {\n  return Web3Utils.isAddress(input);\n};","map":{"version":3,"sources":["../src/address.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,IAAA,SAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AACA,IAAA,iBAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAQA,IAAA,SAAA,GAAA,YAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA,C,CAEA;AACA;;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAEE,OAAA,CAAA,WAAA,GAAA,SAAA,CAAA,WAAA;AACA,OAAA,CAAA,eAAA,GAAA,SAAA,CAAA,eAAA;AACA,OAAA,CAAA,SAAA,GAAA,SAAA,CAAA,SAAA;AACA,OAAA,CAAA,gBAAA,GAAA,SAAA,CAAA,gBAAA;AACA,OAAA,CAAA,gBAAA,GAAA,SAAA,CAAA,gBAAA;AACA,OAAA,CAAA,WAAA,GAAA,SAAA,CAAA,WAAA;AACA,OAAA,CAAA,WAAA,GAAA,SAAA,CAAA,WAAA;AACA,OAAA,CAAA,sBAAA,GAAA,SAAA,CAAA,sBAAA;AACA,OAAA,CAAA,kBAAA,GAAA,SAAA,CAAA,kBAAA;AACA,OAAA,CAAA,gBAAA,GAAA,SAAA,CAAA,gBAAA;AACA,OAAA,CAAA,sBAAA,GAAA,SAAA,CAAA,sBAAA;AACA,OAAA,CAAA,YAAA,GAAA,SAAA,CAAA,YAAA;AACA,OAAA,CAAA,aAAA,GAAA,SAAA,CAAA,aAAA;;AAEF,IAAA,iBAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAAS,OAAA,CAAA,sBAAA,GAAA,iBAAA,CAAA,sBAAA;AAAwB,OAAA,CAAA,iBAAA,GAAA,iBAAA,CAAA,iBAAA;;AAEpB,OAAA,CAAA,mBAAA,GAAsB,UAAC,UAAD,EAAmB;AACpD,SAAA,iBAAA,CAAA,iBAAA,CAAkB,SAAA,CAAA,eAAA,CAAgB,iBAAA,CAAA,gBAAA,CAAiB,SAAA,CAAA,WAAA,CAAY,UAAZ,CAAjB,EAA0C,QAA1C,CAAmD,KAAnD,CAAhB,CAAlB,CAAA;AAA6F,CADlF;;AAGA,OAAA,CAAA,qBAAA,GAAwB,UAAC,UAAD,EAAmB;AACtD,SAAA,iBAAA,CAAA,iBAAA,CAAkB,SAAA,CAAA,eAAA,CAAgB,iBAAA,CAAA,eAAA,CAAgB,SAAA,CAAA,WAAA,CAAY,UAAZ,CAAhB,EAAyC,QAAzC,CAAkD,KAAlD,CAAhB,CAAlB,CAAA;AAA4F,CADjF;;AAGA,OAAA,CAAA,kBAAA,GAAqB,UAAC,SAAD,EAAkB;AAClD,SAAA,iBAAA,CAAA,iBAAA,CACE,SAAA,CAAA,eAAA,CAAgB,iBAAA,CAAA,YAAA,CAAa,iBAAA,CAAA,QAAA,CAAS,SAAA,CAAA,eAAA,CAAgB,SAAhB,CAAT,CAAb,EAAmD,IAAnD,EAAyD,QAAzD,CAAkE,KAAlE,CAAhB,CADF,CAAA;AAEC,CAHU;;AAKA,OAAA,CAAA,iBAAA,GAAoB,UAAC,UAAD,EAAmB;AAClD,SAAA,UAAU,CAAC,UAAX,CAAsB,IAAtB,KAA+B,iBAAA,CAAA,cAAA,CAAe,SAAA,CAAA,WAAA,CAAY,UAAZ,CAAf,CAA/B;AAAsE,CAD3D;;AAGA,OAAA,CAAA,cAAA,GAAiB,UAAC,KAAD,EAAc;AAAc,SAAA,SAAS,CAAC,SAAV,CAAA,KAAA,CAAA;AAA0B,CAAvE","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar address_1 = require(\"@celo/base/lib/address\");\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\nvar Web3Utils = __importStar(require(\"web3-utils\"));\n// Exports moved to @celo/base, forwarding them\n// here for backwards compatibility\nvar address_2 = require(\"@celo/base/lib/address\");\nexports.bufferToHex = address_2.bufferToHex;\nexports.ensureLeading0x = address_2.ensureLeading0x;\nexports.eqAddress = address_2.eqAddress;\nexports.findAddressIndex = address_2.findAddressIndex;\nexports.getAddressChunks = address_2.getAddressChunks;\nexports.hexToBuffer = address_2.hexToBuffer;\nexports.isHexString = address_2.isHexString;\nexports.mapAddressListDataOnto = address_2.mapAddressListDataOnto;\nexports.mapAddressListOnto = address_2.mapAddressListOnto;\nexports.normalizeAddress = address_2.normalizeAddress;\nexports.normalizeAddressWith0x = address_2.normalizeAddressWith0x;\nexports.NULL_ADDRESS = address_2.NULL_ADDRESS;\nexports.trimLeading0x = address_2.trimLeading0x;\nvar ethereumjs_util_2 = require(\"ethereumjs-util\");\nexports.isValidChecksumAddress = ethereumjs_util_2.isValidChecksumAddress;\nexports.toChecksumAddress = ethereumjs_util_2.toChecksumAddress;\nexports.privateKeyToAddress = function (privateKey) {\n    return ethereumjs_util_1.toChecksumAddress(address_1.ensureLeading0x(ethereumjs_util_1.privateToAddress(address_1.hexToBuffer(privateKey)).toString('hex')));\n};\nexports.privateKeyToPublicKey = function (privateKey) {\n    return ethereumjs_util_1.toChecksumAddress(address_1.ensureLeading0x(ethereumjs_util_1.privateToPublic(address_1.hexToBuffer(privateKey)).toString('hex')));\n};\nexports.publicKeyToAddress = function (publicKey) {\n    return ethereumjs_util_1.toChecksumAddress(address_1.ensureLeading0x(ethereumjs_util_1.pubToAddress(ethereumjs_util_1.toBuffer(address_1.ensureLeading0x(publicKey)), true).toString('hex')));\n};\nexports.isValidPrivateKey = function (privateKey) {\n    return privateKey.startsWith('0x') && ethereumjs_util_1.isValidPrivate(address_1.hexToBuffer(privateKey));\n};\nexports.isValidAddress = function (input) { return Web3Utils.isAddress(input); };\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"script"}