{"ast":null,"code":"import { JSBI, Percent, Price } from '@ubeswap/sdk';\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { PairState, usePair } from '../../data/Reserves';\nimport { useTotalSupply } from '../../data/TotalSupply';\nimport { useActiveWeb3React } from '../../hooks';\nimport { tryParseAmount } from '../swap/hooks';\nimport { useCurrencyBalances } from '../wallet/hooks';\nimport { Field, typeInput } from './actions';\nconst ZERO = JSBI.BigInt(0);\nexport function useMintState() {\n  return useSelector(state => state.mint);\n}\nexport function useMintActionHandlers(noLiquidity) {\n  const dispatch = useDispatch();\n  const onFieldAInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_A,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  const onFieldBInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_B,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  return {\n    onFieldAInput,\n    onFieldBInput\n  };\n}\nexport function useDerivedMintInfo(currencyA, currencyB) {\n  var _currencyBalances$Fie, _currencyBalances$Fie2;\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const {\n    independentField,\n    typedValue,\n    otherTypedValue\n  } = useMintState();\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A; // tokens\n\n  const currencies = useMemo(() => ({\n    [Field.CURRENCY_A]: currencyA !== null && currencyA !== void 0 ? currencyA : undefined,\n    [Field.CURRENCY_B]: currencyB !== null && currencyB !== void 0 ? currencyB : undefined\n  }), [currencyA, currencyB]); // pair\n\n  const [pairState, pair] = usePair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]);\n  const totalSupply = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  const noLiquidity = pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.raw, ZERO)); // balances\n\n  const balances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]]);\n  const currencyBalances = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1]\n  }; // amounts\n\n  const independentAmount = tryParseAmount(typedValue, currencies[independentField]);\n  const dependentAmount = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(otherTypedValue, currencies[dependentField]);\n      }\n\n      return undefined;\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = independentAmount;\n      const [tokenA, tokenB] = [currencyA, currencyB];\n\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentTokenAmount = dependentField === Field.CURRENCY_B ? pair.priceOf(tokenA).quote(wrappedIndependentAmount) : pair.priceOf(tokenB).quote(wrappedIndependentAmount);\n        return dependentTokenAmount;\n      }\n\n      return undefined;\n    } else {\n      return undefined;\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, currencyB, pair]);\n  const parsedAmounts = {\n    [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n    [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount\n  };\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const {\n        [Field.CURRENCY_A]: currencyAAmount,\n        [Field.CURRENCY_B]: currencyBAmount\n      } = parsedAmounts;\n\n      if (currencyAAmount && currencyBAmount) {\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, currencyAAmount.raw, currencyBAmount.raw);\n      }\n\n      return undefined;\n    } else {\n      const wrappedCurrencyA = currencyA;\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined;\n    }\n  }, [currencyA, noLiquidity, pair, parsedAmounts]); // liquidity minted\n\n  const liquidityMinted = useMemo(() => {\n    const {\n      [Field.CURRENCY_A]: currencyAAmount,\n      [Field.CURRENCY_B]: currencyBAmount\n    } = parsedAmounts;\n    const [tokenAmountA, tokenAmountB] = [currencyAAmount, currencyBAmount];\n\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB);\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, pair, totalSupply]);\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.raw, totalSupply.add(liquidityMinted).raw);\n    } else {\n      return undefined;\n    }\n  }, [liquidityMinted, totalSupply]);\n  let error;\n\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n\n  if (pairState === PairState.INVALID) {\n    var _error;\n\n    error = (_error = error) !== null && _error !== void 0 ? _error : 'Invalid pair';\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    var _error2;\n\n    error = (_error2 = error) !== null && _error2 !== void 0 ? _error2 : 'Enter an amount';\n  }\n\n  const {\n    [Field.CURRENCY_A]: currencyAAmount,\n    [Field.CURRENCY_B]: currencyBAmount\n  } = parsedAmounts;\n\n  if (currencyAAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie = currencyBalances[Field.CURRENCY_A]) === null || _currencyBalances$Fie === void 0 ? void 0 : _currencyBalances$Fie.lessThan(currencyAAmount))) {\n    var _currencies$Field$CUR;\n\n    error = 'Insufficient ' + ((_currencies$Field$CUR = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR === void 0 ? void 0 : _currencies$Field$CUR.symbol) + ' balance';\n  }\n\n  if (currencyBAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie2 = currencyBalances[Field.CURRENCY_B]) === null || _currencyBalances$Fie2 === void 0 ? void 0 : _currencyBalances$Fie2.lessThan(currencyBAmount))) {\n    var _currencies$Field$CUR2;\n\n    error = 'Insufficient ' + ((_currencies$Field$CUR2 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR2 === void 0 ? void 0 : _currencies$Field$CUR2.symbol) + ' balance';\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error\n  };\n}","map":{"version":3,"sources":["/Users/khoiplus/Desktop/celopad/cpadswaptest/src/state/mint/hooks.ts"],"names":["JSBI","Percent","Price","useCallback","useMemo","useDispatch","useSelector","PairState","usePair","useTotalSupply","useActiveWeb3React","tryParseAmount","useCurrencyBalances","Field","typeInput","ZERO","BigInt","useMintState","state","mint","useMintActionHandlers","noLiquidity","dispatch","onFieldAInput","typedValue","field","CURRENCY_A","onFieldBInput","CURRENCY_B","useDerivedMintInfo","currencyA","currencyB","account","independentField","otherTypedValue","dependentField","currencies","undefined","pairState","pair","totalSupply","liquidityToken","NOT_EXISTS","Boolean","equal","raw","balances","currencyBalances","independentAmount","dependentAmount","wrappedIndependentAmount","tokenA","tokenB","dependentTokenAmount","priceOf","quote","parsedAmounts","price","currencyAAmount","currencyBAmount","currency","wrappedCurrencyA","liquidityMinted","tokenAmountA","tokenAmountB","getLiquidityMinted","poolTokenPercentage","add","error","INVALID","lessThan","symbol"],"mappings":"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","sourcesContent":["import { JSBI, Pair, Percent, Price, Token, TokenAmount } from '@ubeswap/sdk'\nimport { useCallback, useMemo } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { PairState, usePair } from '../../data/Reserves'\nimport { useTotalSupply } from '../../data/TotalSupply'\nimport { useActiveWeb3React } from '../../hooks'\nimport { AppDispatch, AppState } from '../index'\nimport { tryParseAmount } from '../swap/hooks'\nimport { useCurrencyBalances } from '../wallet/hooks'\nimport { Field, typeInput } from './actions'\n\nconst ZERO = JSBI.BigInt(0)\n\nexport function useMintState(): AppState['mint'] {\n  return useSelector<AppState, AppState['mint']>(state => state.mint)\n}\n\nexport function useMintActionHandlers(\n  noLiquidity: boolean | undefined\n): {\n  onFieldAInput: (typedValue: string) => void\n  onFieldBInput: (typedValue: string) => void\n} {\n  const dispatch = useDispatch<AppDispatch>()\n\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  return {\n    onFieldAInput,\n    onFieldBInput\n  }\n}\n\nexport function useDerivedMintInfo(\n  currencyA: Token | undefined,\n  currencyB: Token | undefined\n): {\n  dependentField: Field\n  currencies: { [field in Field]?: Token }\n  pair?: Pair | null\n  pairState: PairState\n  currencyBalances: { [field in Field]?: TokenAmount }\n  parsedAmounts: { [field in Field]?: TokenAmount }\n  price?: Price\n  noLiquidity?: boolean\n  liquidityMinted?: TokenAmount\n  poolTokenPercentage?: Percent\n  error?: string\n} {\n  const { account } = useActiveWeb3React()\n\n  const { independentField, typedValue, otherTypedValue } = useMintState()\n\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // tokens\n  const currencies: { [field in Field]?: Token } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA ?? undefined,\n      [Field.CURRENCY_B]: currencyB ?? undefined\n    }),\n    [currencyA, currencyB]\n  )\n\n  // pair\n  const [pairState, pair] = usePair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B])\n  const totalSupply = useTotalSupply(pair?.liquidityToken)\n\n  const noLiquidity: boolean =\n    pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.raw, ZERO))\n\n  // balances\n  const balances = useCurrencyBalances(account ?? undefined, [\n    currencies[Field.CURRENCY_A],\n    currencies[Field.CURRENCY_B]\n  ])\n  const currencyBalances: { [field in Field]?: TokenAmount } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1]\n  }\n\n  // amounts\n  const independentAmount: TokenAmount | undefined = tryParseAmount(typedValue, currencies[independentField])\n  const dependentAmount: TokenAmount | undefined = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(otherTypedValue, currencies[dependentField])\n      }\n      return undefined\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = independentAmount\n      const [tokenA, tokenB] = [currencyA, currencyB]\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentTokenAmount =\n          dependentField === Field.CURRENCY_B\n            ? pair.priceOf(tokenA).quote(wrappedIndependentAmount)\n            : pair.priceOf(tokenB).quote(wrappedIndependentAmount)\n        return dependentTokenAmount\n      }\n      return undefined\n    } else {\n      return undefined\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, currencyB, pair])\n  const parsedAmounts: { [field in Field]: TokenAmount | undefined } = {\n    [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n    [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount\n  }\n\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n      if (currencyAAmount && currencyBAmount) {\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, currencyAAmount.raw, currencyBAmount.raw)\n      }\n      return undefined\n    } else {\n      const wrappedCurrencyA = currencyA\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined\n    }\n  }, [currencyA, noLiquidity, pair, parsedAmounts])\n\n  // liquidity minted\n  const liquidityMinted = useMemo(() => {\n    const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n    const [tokenAmountA, tokenAmountB] = [currencyAAmount, currencyBAmount]\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB)\n    } else {\n      return undefined\n    }\n  }, [parsedAmounts, pair, totalSupply])\n\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.raw, totalSupply.add(liquidityMinted).raw)\n    } else {\n      return undefined\n    }\n  }, [liquidityMinted, totalSupply])\n\n  let error: string | undefined\n  if (!account) {\n    error = 'Connect Wallet'\n  }\n\n  if (pairState === PairState.INVALID) {\n    error = error ?? 'Invalid pair'\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    error = error ?? 'Enter an amount'\n  }\n\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n\n  if (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    error = 'Insufficient ' + currencies[Field.CURRENCY_A]?.symbol + ' balance'\n  }\n\n  if (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    error = 'Insufficient ' + currencies[Field.CURRENCY_B]?.symbol + ' balance'\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error\n  }\n}\n"]},"metadata":{},"sourceType":"module"}