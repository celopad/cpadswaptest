{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar address_1 = require(\"@celo/base/lib/address\");\n\nvar connect_1 = require(\"@celo/connect\");\n\nvar BaseWrapper_1 = require(\"./BaseWrapper\");\n/**\n * Class that wraps the MetaTransactionWallet\n */\n\n\nvar MetaTransactionWalletWrapper =\n/** @class */\nfunction (_super) {\n  __extends(MetaTransactionWalletWrapper, _super);\n\n  function MetaTransactionWalletWrapper() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.getMetaTransactionDigestParams = function (tx, nonce) {\n      var rawTx = exports.toRawTransaction(tx);\n      return [rawTx.destination, rawTx.value, rawTx.data, nonce];\n    };\n\n    _this.getMetaTransactionDigest = BaseWrapper_1.proxyCall(_this.contract.methods.getMetaTransactionDigest, _this.getMetaTransactionDigestParams, BaseWrapper_1.stringIdentity);\n\n    _this.getMetaTransactionSignerParams = function (tx, nonce, signature) {\n      var rawTx = exports.toRawTransaction(tx);\n      return [rawTx.destination, rawTx.value, rawTx.data, nonce, signature.v, signature.r, signature.s];\n    };\n\n    _this.getMetaTransactionSigner = BaseWrapper_1.proxyCall(_this.contract.methods.getMetaTransactionSigner, _this.getMetaTransactionSignerParams, BaseWrapper_1.stringIdentity);\n    _this.eip712DomainSeparator = BaseWrapper_1.proxyCall(_this.contract.methods.eip712DomainSeparator);\n    _this.isOwner = BaseWrapper_1.proxyCall(_this.contract.methods.isOwner);\n    _this.nonce = BaseWrapper_1.proxyCall(_this.contract.methods.nonce, undefined, BaseWrapper_1.valueToInt);\n    _this.getSigner = BaseWrapper_1.proxyCall(_this.contract.methods.signer, undefined, BaseWrapper_1.stringIdentity);\n    _this.transferOwnership = BaseWrapper_1.proxySend(_this.kit, _this.contract.methods.transferOwnership);\n    _this.setSigner = BaseWrapper_1.proxySend(_this.kit, _this.contract.methods.setSigner);\n    _this.setEip712DomainSeparator = BaseWrapper_1.proxySend(_this.kit, _this.contract.methods.setEip712DomainSeparator);\n    return _this;\n  }\n  /**\n   * Execute a transaction originating from the MTW\n   * Reverts if the caller is not a signer\n   * @param tx a TransactionInput\n   */\n\n\n  MetaTransactionWalletWrapper.prototype.executeTransaction = function (tx) {\n    var rawTx = exports.toRawTransaction(tx);\n    return connect_1.toTransactionObject(this.kit.connection, this.contract.methods.executeTransaction(rawTx.destination, rawTx.value, rawTx.data));\n  };\n  /**\n   * Execute a batch of transactions originating from the MTW\n   * Reverts if the caller is not a signer\n   * @param txs An array of TransactionInput\n   */\n\n\n  MetaTransactionWalletWrapper.prototype.executeTransactions = function (txs) {\n    var _a = exports.toTransactionBatch(txs),\n        destinations = _a.destinations,\n        values = _a.values,\n        callData = _a.callData,\n        callDataLengths = _a.callDataLengths;\n\n    return connect_1.toTransactionObject(this.kit.connection, this.contract.methods.executeTransactions(destinations, values, callData, callDataLengths));\n  };\n  /**\n   * Execute a signed meta transaction\n   * Reverts if meta-tx signer is not a signer for the wallet\n   * @param tx a TransactionInput\n   * @param signature a Signature\n   */\n\n\n  MetaTransactionWalletWrapper.prototype.executeMetaTransaction = function (tx, signature) {\n    var rawTx = exports.toRawTransaction(tx);\n    return connect_1.toTransactionObject(this.kit.connection, this.contract.methods.executeMetaTransaction(rawTx.destination, rawTx.value, rawTx.data, signature.v, signature.r, signature.s));\n  };\n  /**\n   * Signs a meta transaction as EIP712 typed data\n   * @param tx a TransactionWrapper\n   * @param nonce Optional -- will query contract state if not passed\n   * @returns signature a Signature\n   */\n\n\n  MetaTransactionWalletWrapper.prototype.signMetaTransaction = function (tx, nonce) {\n    return __awaiter(this, void 0, void 0, function () {\n      var typedData, _a, _b, signer;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!(nonce === undefined)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.nonce()];\n\n          case 1:\n            nonce = _c.sent();\n            _c.label = 2;\n\n          case 2:\n            _a = exports.buildMetaTxTypedData;\n            _b = [this.address, exports.toRawTransaction(tx), nonce];\n            return [4\n            /*yield*/\n            , this.chainId()];\n\n          case 3:\n            typedData = _a.apply(void 0, _b.concat([_c.sent()]));\n            return [4\n            /*yield*/\n            , this.signer()];\n\n          case 4:\n            signer = _c.sent();\n            return [2\n            /*return*/\n            , this.kit.connection.signTypedData(signer, typedData)];\n        }\n      });\n    });\n  };\n  /**\n   * Execute a signed meta transaction\n   * Reverts if meta-tx signer is not a signer for the wallet\n   * @param tx a TransactionInput\n   */\n\n\n  MetaTransactionWalletWrapper.prototype.signAndExecuteMetaTransaction = function (tx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signature;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.signMetaTransaction(tx)];\n\n          case 1:\n            signature = _a.sent();\n            return [2\n            /*return*/\n            , this.executeMetaTransaction(tx, signature)];\n        }\n      });\n    });\n  };\n\n  MetaTransactionWalletWrapper.prototype.chainId = function () {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _b, _c, _d;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _b = this;\n            if (!((_a = this._chainId) !== null && _a !== void 0)) return [3\n            /*break*/\n            , 1];\n            _c = _a;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.kit.connection.chainId()];\n\n          case 2:\n            _c = _e.sent();\n            _e.label = 3;\n\n          case 3:\n            _b._chainId = _c;\n            if (!(this._chainId === undefined)) return [3\n            /*break*/\n            , 5];\n            _d = this;\n            return [4\n            /*yield*/\n            , this.kit.connection.chainId()];\n\n          case 4:\n            _d._chainId = _e.sent();\n            _e.label = 5;\n\n          case 5:\n            return [2\n            /*return*/\n            , this._chainId];\n        }\n      });\n    });\n  };\n\n  MetaTransactionWalletWrapper.prototype.signer = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(this._signer === undefined)) return [3\n            /*break*/\n            , 2];\n            _a = this;\n            return [4\n            /*yield*/\n            , this.getSigner()];\n\n          case 1:\n            _a._signer = _b.sent();\n            _b.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , this._signer];\n        }\n      });\n    });\n  };\n\n  return MetaTransactionWalletWrapper;\n}(BaseWrapper_1.BaseWrapper);\n\nexports.MetaTransactionWalletWrapper = MetaTransactionWalletWrapper;\n/**\n * Turns any possible way to pass in a transaction into the raw values\n * that are actually required. This is used both internally to normalize\n * ways in which transactions are passed in but also public in order\n * for one instance of ContractKit to serialize a meta transaction to\n * send over the wire and be consumed somewhere else.\n * @param tx TransactionInput<any> union of all the ways we expect transactions\n * @returns a RawTransactions that's serializable\n */\n\nexports.toRawTransaction = function (tx) {\n  if ('destination' in tx) {\n    return tx;\n  } else if ('value' in tx) {\n    return {\n      destination: tx.txo._parent.options.address,\n      data: tx.txo.encodeABI(),\n      value: BaseWrapper_1.valueToString(tx.value)\n    };\n  } else {\n    return {\n      destination: tx._parent.options.address,\n      data: tx.encodeABI(),\n      value: '0'\n    };\n  }\n};\n/**\n * Turns an array of transaction inputs into the argument that\n * need to be passed to the executeTransactions call.\n * Main transformation is that all the `data` parts of each\n * transaction in the batch are concatenated and an array\n * of lengths is constructed.\n * This is a gas optimisation on the contract.\n * @param txs Array<TransactionInput<any>> array of txs\n * @returns Params for the executeTransactions method call\n */\n\n\nexports.toTransactionBatch = function (txs) {\n  var rawTxs = txs.map(exports.toRawTransaction);\n  return {\n    destinations: rawTxs.map(function (rtx) {\n      return rtx.destination;\n    }),\n    values: rawTxs.map(function (rtx) {\n      return rtx.value;\n    }),\n    callData: address_1.ensureLeading0x(rawTxs.map(function (rtx) {\n      return address_1.trimLeading0x(rtx.data);\n    }).join('')),\n    callDataLengths: rawTxs.map(function (rtx) {\n      return address_1.trimLeading0x(rtx.data).length / 2;\n    })\n  };\n};\n\nexports.buildMetaTxTypedData = function (walletAddress, tx, nonce, chainId) {\n  return {\n    types: {\n      EIP712Domain: [{\n        name: 'name',\n        type: 'string'\n      }, {\n        name: 'version',\n        type: 'string'\n      }, {\n        name: 'chainId',\n        type: 'uint256'\n      }, {\n        name: 'verifyingContract',\n        type: 'address'\n      }],\n      ExecuteMetaTransaction: [{\n        name: 'destination',\n        type: 'address'\n      }, {\n        name: 'value',\n        type: 'uint256'\n      }, {\n        name: 'data',\n        type: 'bytes'\n      }, {\n        name: 'nonce',\n        type: 'uint256'\n      }]\n    },\n    primaryType: 'ExecuteMetaTransaction',\n    domain: {\n      name: 'MetaTransactionWallet',\n      version: '1.1',\n      chainId: chainId,\n      verifyingContract: walletAddress\n    },\n    message: tx ? __assign(__assign({}, tx), {\n      nonce: nonce\n    }) : {}\n  };\n};","map":{"version":3,"sources":["../../src/wrappers/MetaTransactionWallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar address_1 = require(\"@celo/base/lib/address\");\nvar connect_1 = require(\"@celo/connect\");\nvar BaseWrapper_1 = require(\"./BaseWrapper\");\n/**\n * Class that wraps the MetaTransactionWallet\n */\nvar MetaTransactionWalletWrapper = /** @class */ (function (_super) {\n    __extends(MetaTransactionWalletWrapper, _super);\n    function MetaTransactionWalletWrapper() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.getMetaTransactionDigestParams = function (tx, nonce) {\n            var rawTx = exports.toRawTransaction(tx);\n            return [rawTx.destination, rawTx.value, rawTx.data, nonce];\n        };\n        _this.getMetaTransactionDigest = BaseWrapper_1.proxyCall(_this.contract.methods.getMetaTransactionDigest, _this.getMetaTransactionDigestParams, BaseWrapper_1.stringIdentity);\n        _this.getMetaTransactionSignerParams = function (tx, nonce, signature) {\n            var rawTx = exports.toRawTransaction(tx);\n            return [\n                rawTx.destination,\n                rawTx.value,\n                rawTx.data,\n                nonce,\n                signature.v,\n                signature.r,\n                signature.s,\n            ];\n        };\n        _this.getMetaTransactionSigner = BaseWrapper_1.proxyCall(_this.contract.methods.getMetaTransactionSigner, _this.getMetaTransactionSignerParams, BaseWrapper_1.stringIdentity);\n        _this.eip712DomainSeparator = BaseWrapper_1.proxyCall(_this.contract.methods.eip712DomainSeparator);\n        _this.isOwner = BaseWrapper_1.proxyCall(_this.contract.methods.isOwner);\n        _this.nonce = BaseWrapper_1.proxyCall(_this.contract.methods.nonce, undefined, BaseWrapper_1.valueToInt);\n        _this.getSigner = BaseWrapper_1.proxyCall(_this.contract.methods.signer, undefined, BaseWrapper_1.stringIdentity);\n        _this.transferOwnership = BaseWrapper_1.proxySend(_this.kit, _this.contract.methods.transferOwnership);\n        _this.setSigner = BaseWrapper_1.proxySend(_this.kit, _this.contract.methods.setSigner);\n        _this.setEip712DomainSeparator = BaseWrapper_1.proxySend(_this.kit, _this.contract.methods.setEip712DomainSeparator);\n        return _this;\n    }\n    /**\n     * Execute a transaction originating from the MTW\n     * Reverts if the caller is not a signer\n     * @param tx a TransactionInput\n     */\n    MetaTransactionWalletWrapper.prototype.executeTransaction = function (tx) {\n        var rawTx = exports.toRawTransaction(tx);\n        return connect_1.toTransactionObject(this.kit.connection, this.contract.methods.executeTransaction(rawTx.destination, rawTx.value, rawTx.data));\n    };\n    /**\n     * Execute a batch of transactions originating from the MTW\n     * Reverts if the caller is not a signer\n     * @param txs An array of TransactionInput\n     */\n    MetaTransactionWalletWrapper.prototype.executeTransactions = function (txs) {\n        var _a = exports.toTransactionBatch(txs), destinations = _a.destinations, values = _a.values, callData = _a.callData, callDataLengths = _a.callDataLengths;\n        return connect_1.toTransactionObject(this.kit.connection, this.contract.methods.executeTransactions(destinations, values, callData, callDataLengths));\n    };\n    /**\n     * Execute a signed meta transaction\n     * Reverts if meta-tx signer is not a signer for the wallet\n     * @param tx a TransactionInput\n     * @param signature a Signature\n     */\n    MetaTransactionWalletWrapper.prototype.executeMetaTransaction = function (tx, signature) {\n        var rawTx = exports.toRawTransaction(tx);\n        return connect_1.toTransactionObject(this.kit.connection, this.contract.methods.executeMetaTransaction(rawTx.destination, rawTx.value, rawTx.data, signature.v, signature.r, signature.s));\n    };\n    /**\n     * Signs a meta transaction as EIP712 typed data\n     * @param tx a TransactionWrapper\n     * @param nonce Optional -- will query contract state if not passed\n     * @returns signature a Signature\n     */\n    MetaTransactionWalletWrapper.prototype.signMetaTransaction = function (tx, nonce) {\n        return __awaiter(this, void 0, void 0, function () {\n            var typedData, _a, _b, signer;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (!(nonce === undefined)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.nonce()];\n                    case 1:\n                        nonce = _c.sent();\n                        _c.label = 2;\n                    case 2:\n                        _a = exports.buildMetaTxTypedData;\n                        _b = [this.address,\n                            exports.toRawTransaction(tx),\n                            nonce];\n                        return [4 /*yield*/, this.chainId()];\n                    case 3:\n                        typedData = _a.apply(void 0, _b.concat([_c.sent()]));\n                        return [4 /*yield*/, this.signer()];\n                    case 4:\n                        signer = _c.sent();\n                        return [2 /*return*/, this.kit.connection.signTypedData(signer, typedData)];\n                }\n            });\n        });\n    };\n    /**\n     * Execute a signed meta transaction\n     * Reverts if meta-tx signer is not a signer for the wallet\n     * @param tx a TransactionInput\n     */\n    MetaTransactionWalletWrapper.prototype.signAndExecuteMetaTransaction = function (tx) {\n        return __awaiter(this, void 0, void 0, function () {\n            var signature;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.signMetaTransaction(tx)];\n                    case 1:\n                        signature = _a.sent();\n                        return [2 /*return*/, this.executeMetaTransaction(tx, signature)];\n                }\n            });\n        });\n    };\n    MetaTransactionWalletWrapper.prototype.chainId = function () {\n        var _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var _b, _c, _d;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        _b = this;\n                        if (!((_a = this._chainId) !== null && _a !== void 0)) return [3 /*break*/, 1];\n                        _c = _a;\n                        return [3 /*break*/, 3];\n                    case 1: return [4 /*yield*/, this.kit.connection.chainId()];\n                    case 2:\n                        _c = (_e.sent());\n                        _e.label = 3;\n                    case 3:\n                        _b._chainId = _c;\n                        if (!(this._chainId === undefined)) return [3 /*break*/, 5];\n                        _d = this;\n                        return [4 /*yield*/, this.kit.connection.chainId()];\n                    case 4:\n                        _d._chainId = _e.sent();\n                        _e.label = 5;\n                    case 5: return [2 /*return*/, this._chainId];\n                }\n            });\n        });\n    };\n    MetaTransactionWalletWrapper.prototype.signer = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!(this._signer === undefined)) return [3 /*break*/, 2];\n                        _a = this;\n                        return [4 /*yield*/, this.getSigner()];\n                    case 1:\n                        _a._signer = _b.sent();\n                        _b.label = 2;\n                    case 2: return [2 /*return*/, this._signer];\n                }\n            });\n        });\n    };\n    return MetaTransactionWalletWrapper;\n}(BaseWrapper_1.BaseWrapper));\nexports.MetaTransactionWalletWrapper = MetaTransactionWalletWrapper;\n/**\n * Turns any possible way to pass in a transaction into the raw values\n * that are actually required. This is used both internally to normalize\n * ways in which transactions are passed in but also public in order\n * for one instance of ContractKit to serialize a meta transaction to\n * send over the wire and be consumed somewhere else.\n * @param tx TransactionInput<any> union of all the ways we expect transactions\n * @returns a RawTransactions that's serializable\n */\nexports.toRawTransaction = function (tx) {\n    if ('destination' in tx) {\n        return tx;\n    }\n    else if ('value' in tx) {\n        return {\n            destination: tx.txo._parent.options.address,\n            data: tx.txo.encodeABI(),\n            value: BaseWrapper_1.valueToString(tx.value),\n        };\n    }\n    else {\n        return {\n            destination: tx._parent.options.address,\n            data: tx.encodeABI(),\n            value: '0',\n        };\n    }\n};\n/**\n * Turns an array of transaction inputs into the argument that\n * need to be passed to the executeTransactions call.\n * Main transformation is that all the `data` parts of each\n * transaction in the batch are concatenated and an array\n * of lengths is constructed.\n * This is a gas optimisation on the contract.\n * @param txs Array<TransactionInput<any>> array of txs\n * @returns Params for the executeTransactions method call\n */\nexports.toTransactionBatch = function (txs) {\n    var rawTxs = txs.map(exports.toRawTransaction);\n    return {\n        destinations: rawTxs.map(function (rtx) { return rtx.destination; }),\n        values: rawTxs.map(function (rtx) { return rtx.value; }),\n        callData: address_1.ensureLeading0x(rawTxs.map(function (rtx) { return address_1.trimLeading0x(rtx.data); }).join('')),\n        callDataLengths: rawTxs.map(function (rtx) { return address_1.trimLeading0x(rtx.data).length / 2; }),\n    };\n};\nexports.buildMetaTxTypedData = function (walletAddress, tx, nonce, chainId) {\n    return {\n        types: {\n            EIP712Domain: [\n                { name: 'name', type: 'string' },\n                { name: 'version', type: 'string' },\n                { name: 'chainId', type: 'uint256' },\n                { name: 'verifyingContract', type: 'address' },\n            ],\n            ExecuteMetaTransaction: [\n                { name: 'destination', type: 'address' },\n                { name: 'value', type: 'uint256' },\n                { name: 'data', type: 'bytes' },\n                { name: 'nonce', type: 'uint256' },\n            ],\n        },\n        primaryType: 'ExecuteMetaTransaction',\n        domain: {\n            name: 'MetaTransactionWallet',\n            version: '1.1',\n            chainId: chainId,\n            verifyingContract: walletAddress,\n        },\n        message: tx ? __assign(__assign({}, tx), { nonce: nonce }) : {},\n    };\n};\n//# sourceMappingURL=MetaTransactionWallet.js.map"]},"metadata":{},"sourceType":"script"}