{"ast":null,"code":"import { Trade } from '@ubeswap/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useMemo } from 'react';\nimport { useUserSingleHopOnly } from 'state/user/hooks';\nimport { isTradeBetter } from 'utils/trades';\nimport { BASES_TO_CHECK_TRADES_AGAINST, BETTER_TRADE_LESS_HOPS_THRESHOLD } from '../constants';\nimport { PairState, usePairs } from '../data/Reserves';\nimport { useActiveWeb3React } from './index';\nimport { useUnsupportedTokens } from './Tokens';\n\nfunction useAllCommonPairs(currencyA, currencyB) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const bases = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : [];\n  const [tokenA, tokenB] = [currencyA, currencyB];\n  const basePairs = useMemo(() => flatMap(bases, base => bases.map(otherBase => [base, otherBase])).filter(([t0, t1]) => t0.address !== t1.address), [bases]);\n  const allPairCombinations = useMemo(() => tokenA && tokenB ? [// the direct pair\n  [tokenA, tokenB], // token A against all bases\n  ...bases.map(base => [tokenA, base]), // token B against all bases\n  ...bases.map(base => [tokenB, base]), // each base against all bases\n  ...basePairs].filter(tokens => Boolean(tokens[0] && tokens[1])).filter(([t0, t1]) => t0.address !== t1.address) : [], [tokenA, tokenB, bases, basePairs]);\n  const allPairs = usePairs(allPairCombinations); // only pass along valid pairs, non-duplicated pairs\n\n  return useMemo(() => Object.values(allPairs // filter out invalid pairs\n  .filter(result => Boolean(result[0] === PairState.EXISTS && result[1])) // filter out duplicated pairs\n  .reduce((memo, [, curr]) => {\n    var _memo$curr$liquidityT;\n\n    memo[curr.liquidityToken.address] = (_memo$curr$liquidityT = memo[curr.liquidityToken.address]) !== null && _memo$curr$liquidityT !== void 0 ? _memo$curr$liquidityT : curr;\n    return memo;\n  }, {})), [allPairs]);\n}\n\nconst MAX_HOPS = 3;\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\n\nexport function useTradeExactIn(currencyAmountIn, currencyOut) {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyOut);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact;\n\n        return (_Trade$bestTradeExact = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact !== void 0 ? _Trade$bestTradeExact : null;\n      } // search through trades with varying hops, find best trade out of them\n\n\n      let bestTradeSoFar = null;\n\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact2;\n\n        const currentTrade = (_Trade$bestTradeExact2 = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact2 !== void 0 ? _Trade$bestTradeExact2 : null; // if current trade is best yet, save it\n\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n\n      return bestTradeSoFar;\n    }\n\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly]);\n}\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\n\nexport function useTradeExactOut(currencyIn, currencyAmountOut) {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut === null || currencyAmountOut === void 0 ? void 0 : currencyAmountOut.currency);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact3;\n\n        return (_Trade$bestTradeExact3 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact3 !== void 0 ? _Trade$bestTradeExact3 : null;\n      } // search through trades with varying hops, find best trade out of them\n\n\n      let bestTradeSoFar = null;\n\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact4;\n\n        const currentTrade = (_Trade$bestTradeExact4 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact4 !== void 0 ? _Trade$bestTradeExact4 : null;\n\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n\n      return bestTradeSoFar;\n    }\n\n    return null;\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly]);\n}\nexport function useIsTransactionUnsupported(currencyIn, currencyOut) {\n  const unsupportedToken = useUnsupportedTokens();\n  const tokenIn = currencyIn;\n  const tokenOut = currencyOut; // if unsupported list loaded & either token on list, mark as unsupported\n\n  if (unsupportedToken) {\n    if (tokenIn && Object.keys(unsupportedToken).includes(tokenIn.address)) {\n      return true;\n    }\n\n    if (tokenOut && Object.keys(unsupportedToken).includes(tokenOut.address)) {\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/khoiplus/Desktop/celopad/cpadswaptest/src/hooks/Trades.ts"],"names":["Trade","flatMap","useMemo","useUserSingleHopOnly","isTradeBetter","BASES_TO_CHECK_TRADES_AGAINST","BETTER_TRADE_LESS_HOPS_THRESHOLD","PairState","usePairs","useActiveWeb3React","useUnsupportedTokens","useAllCommonPairs","currencyA","currencyB","chainId","bases","tokenA","tokenB","basePairs","base","map","otherBase","filter","t0","t1","address","allPairCombinations","tokens","Boolean","allPairs","Object","values","result","EXISTS","reduce","memo","curr","liquidityToken","MAX_HOPS","useTradeExactIn","currencyAmountIn","currencyOut","allowedPairs","currency","singleHopOnly","length","bestTradeExactIn","maxHops","maxNumResults","bestTradeSoFar","i","currentTrade","useTradeExactOut","currencyIn","currencyAmountOut","bestTradeExactOut","useIsTransactionUnsupported","unsupportedToken","tokenIn","tokenOut","keys","includes"],"mappings":"AAAA,SAAmCA,KAAnC,QAAgD,cAAhD;AACA,OAAOC,OAAP,MAAoB,gBAApB;AACA,SAASC,OAAT,QAAwB,OAAxB;AACA,SAASC,oBAAT,QAAqC,kBAArC;AACA,SAASC,aAAT,QAA8B,cAA9B;AACA,SAASC,6BAAT,EAAwCC,gCAAxC,QAAgF,cAAhF;AACA,SAASC,SAAT,EAAoBC,QAApB,QAAoC,kBAApC;AACA,SAASC,kBAAT,QAAmC,SAAnC;AACA,SAASC,oBAAT,QAAqC,UAArC;;AAEA,SAASC,iBAAT,CAA2BC,SAA3B,EAA8CC,SAA9C,EAAyE;AACvE,QAAM;AAAEC,IAAAA;AAAF,MAAcL,kBAAkB,EAAtC;AAEA,QAAMM,KAAc,GAAGD,OAAO,GAAGT,6BAA6B,CAACS,OAAD,CAAhC,GAA4C,EAA1E;AACA,QAAM,CAACE,MAAD,EAASC,MAAT,IAAmB,CAACL,SAAD,EAAYC,SAAZ,CAAzB;AAEA,QAAMK,SAA2B,GAAGhB,OAAO,CACzC,MACED,OAAO,CAACc,KAAD,EAASI,IAAD,IAA4BJ,KAAK,CAACK,GAAN,CAAUC,SAAS,IAAI,CAACF,IAAD,EAAOE,SAAP,CAAvB,CAApC,CAAP,CAAsFC,MAAtF,CACE,CAAC,CAACC,EAAD,EAAKC,EAAL,CAAD,KAAcD,EAAE,CAACE,OAAH,KAAeD,EAAE,CAACC,OADlC,CAFuC,EAKzC,CAACV,KAAD,CALyC,CAA3C;AAQA,QAAMW,mBAAqC,GAAGxB,OAAO,CACnD,MACEc,MAAM,IAAIC,MAAV,GACI,CACE;AACA,GAACD,MAAD,EAASC,MAAT,CAFF,EAGE;AACA,KAAGF,KAAK,CAACK,GAAN,CAAWD,IAAD,IAA0B,CAACH,MAAD,EAASG,IAAT,CAApC,CAJL,EAKE;AACA,KAAGJ,KAAK,CAACK,GAAN,CAAWD,IAAD,IAA0B,CAACF,MAAD,EAASE,IAAT,CAApC,CANL,EAOE;AACA,KAAGD,SARL,EAUGI,MAVH,CAUWK,MAAD,IAAsCC,OAAO,CAACD,MAAM,CAAC,CAAD,CAAN,IAAaA,MAAM,CAAC,CAAD,CAApB,CAVvD,EAWGL,MAXH,CAWU,CAAC,CAACC,EAAD,EAAKC,EAAL,CAAD,KAAcD,EAAE,CAACE,OAAH,KAAeD,EAAE,CAACC,OAX1C,CADJ,GAaI,EAf6C,EAgBnD,CAACT,MAAD,EAASC,MAAT,EAAiBF,KAAjB,EAAwBG,SAAxB,CAhBmD,CAArD;AAmBA,QAAMW,QAAQ,GAAGrB,QAAQ,CAACkB,mBAAD,CAAzB,CAjCuE,CAmCvE;;AACA,SAAOxB,OAAO,CACZ,MACE4B,MAAM,CAACC,MAAP,CACEF,QAAQ,CACN;AADM,GAELP,MAFH,CAEWU,MAAD,IAAgDJ,OAAO,CAACI,MAAM,CAAC,CAAD,CAAN,KAAczB,SAAS,CAAC0B,MAAxB,IAAkCD,MAAM,CAAC,CAAD,CAAzC,CAFjE,EAGE;AAHF,GAIGE,MAJH,CAI2C,CAACC,IAAD,EAAO,GAAGC,IAAH,CAAP,KAAoB;AAAA;;AAC3DD,IAAAA,IAAI,CAACC,IAAI,CAACC,cAAL,CAAoBZ,OAArB,CAAJ,4BAAoCU,IAAI,CAACC,IAAI,CAACC,cAAL,CAAoBZ,OAArB,CAAxC,yEAAyEW,IAAzE;AACA,WAAOD,IAAP;AACD,GAPH,EAOK,EAPL,CADF,CAFU,EAYZ,CAACN,QAAD,CAZY,CAAd;AAcD;;AAED,MAAMS,QAAQ,GAAG,CAAjB;AAEA;;;;AAGA,OAAO,SAASC,eAAT,CAAyBC,gBAAzB,EAAyDC,WAAzD,EAA4F;AACjG,QAAMC,YAAY,GAAG/B,iBAAiB,CAAC6B,gBAAD,aAACA,gBAAD,uBAACA,gBAAgB,CAAEG,QAAnB,EAA6BF,WAA7B,CAAtC;AAEA,QAAM,CAACG,aAAD,IAAkBzC,oBAAoB,EAA5C;AAEA,SAAOD,OAAO,CAAC,MAAM;AACnB,QAAIsC,gBAAgB,IAAIC,WAApB,IAAmCC,YAAY,CAACG,MAAb,GAAsB,CAA7D,EAAgE;AAC9D,UAAID,aAAJ,EAAmB;AAAA;;AACjB,wCACE5C,KAAK,CAAC8C,gBAAN,CAAuBJ,YAAvB,EAAqCF,gBAArC,EAAuDC,WAAvD,EAAoE;AAAEM,UAAAA,OAAO,EAAE,CAAX;AAAcC,UAAAA,aAAa,EAAE;AAA7B,SAApE,EAAsG,CAAtG,CADF,yEAEE,IAFF;AAID,OAN6D,CAO9D;;;AACA,UAAIC,cAA4B,GAAG,IAAnC;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIZ,QAArB,EAA+BY,CAAC,EAAhC,EAAoC;AAAA;;AAClC,cAAMC,YAA0B,6BAC9BnD,KAAK,CAAC8C,gBAAN,CAAuBJ,YAAvB,EAAqCF,gBAArC,EAAuDC,WAAvD,EAAoE;AAAEM,UAAAA,OAAO,EAAEG,CAAX;AAAcF,UAAAA,aAAa,EAAE;AAA7B,SAApE,EAAsG,CAAtG,CAD8B,2EAE9B,IAFF,CADkC,CAIlC;;AACA,YAAI5C,aAAa,CAAC6C,cAAD,EAAiBE,YAAjB,EAA+B7C,gCAA/B,CAAjB,EAAmF;AACjF2C,UAAAA,cAAc,GAAGE,YAAjB;AACD;AACF;;AACD,aAAOF,cAAP;AACD;;AAED,WAAO,IAAP;AACD,GAvBa,EAuBX,CAACP,YAAD,EAAeF,gBAAf,EAAiCC,WAAjC,EAA8CG,aAA9C,CAvBW,CAAd;AAwBD;AAED;;;;AAGA,OAAO,SAASQ,gBAAT,CAA0BC,UAA1B,EAA8CC,iBAA9C,EAA6F;AAClG,QAAMZ,YAAY,GAAG/B,iBAAiB,CAAC0C,UAAD,EAAaC,iBAAb,aAAaA,iBAAb,uBAAaA,iBAAiB,CAAEX,QAAhC,CAAtC;AAEA,QAAM,CAACC,aAAD,IAAkBzC,oBAAoB,EAA5C;AAEA,SAAOD,OAAO,CAAC,MAAM;AACnB,QAAImD,UAAU,IAAIC,iBAAd,IAAmCZ,YAAY,CAACG,MAAb,GAAsB,CAA7D,EAAgE;AAC9D,UAAID,aAAJ,EAAmB;AAAA;;AACjB,yCACE5C,KAAK,CAACuD,iBAAN,CAAwBb,YAAxB,EAAsCW,UAAtC,EAAkDC,iBAAlD,EAAqE;AAAEP,UAAAA,OAAO,EAAE,CAAX;AAAcC,UAAAA,aAAa,EAAE;AAA7B,SAArE,EAAuG,CAAvG,CADF,2EAEE,IAFF;AAID,OAN6D,CAO9D;;;AACA,UAAIC,cAA4B,GAAG,IAAnC;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIZ,QAArB,EAA+BY,CAAC,EAAhC,EAAoC;AAAA;;AAClC,cAAMC,YAAY,6BAChBnD,KAAK,CAACuD,iBAAN,CAAwBb,YAAxB,EAAsCW,UAAtC,EAAkDC,iBAAlD,EAAqE;AAAEP,UAAAA,OAAO,EAAEG,CAAX;AAAcF,UAAAA,aAAa,EAAE;AAA7B,SAArE,EAAuG,CAAvG,CADgB,2EAEhB,IAFF;;AAGA,YAAI5C,aAAa,CAAC6C,cAAD,EAAiBE,YAAjB,EAA+B7C,gCAA/B,CAAjB,EAAmF;AACjF2C,UAAAA,cAAc,GAAGE,YAAjB;AACD;AACF;;AACD,aAAOF,cAAP;AACD;;AACD,WAAO,IAAP;AACD,GArBa,EAqBX,CAACI,UAAD,EAAaC,iBAAb,EAAgCZ,YAAhC,EAA8CE,aAA9C,CArBW,CAAd;AAsBD;AAED,OAAO,SAASY,2BAAT,CAAqCH,UAArC,EAAyDZ,WAAzD,EAAuF;AAC5F,QAAMgB,gBAA8C,GAAG/C,oBAAoB,EAA3E;AAEA,QAAMgD,OAAO,GAAGL,UAAhB;AACA,QAAMM,QAAQ,GAAGlB,WAAjB,CAJ4F,CAM5F;;AACA,MAAIgB,gBAAJ,EAAsB;AACpB,QAAIC,OAAO,IAAI5B,MAAM,CAAC8B,IAAP,CAAYH,gBAAZ,EAA8BI,QAA9B,CAAuCH,OAAO,CAACjC,OAA/C,CAAf,EAAwE;AACtE,aAAO,IAAP;AACD;;AACD,QAAIkC,QAAQ,IAAI7B,MAAM,CAAC8B,IAAP,CAAYH,gBAAZ,EAA8BI,QAA9B,CAAuCF,QAAQ,CAAClC,OAAhD,CAAhB,EAA0E;AACxE,aAAO,IAAP;AACD;AACF;;AAED,SAAO,KAAP;AACD","sourcesContent":["import { Pair, Token, TokenAmount, Trade } from '@ubeswap/sdk'\nimport flatMap from 'lodash.flatmap'\nimport { useMemo } from 'react'\nimport { useUserSingleHopOnly } from 'state/user/hooks'\nimport { isTradeBetter } from 'utils/trades'\nimport { BASES_TO_CHECK_TRADES_AGAINST, BETTER_TRADE_LESS_HOPS_THRESHOLD } from '../constants'\nimport { PairState, usePairs } from '../data/Reserves'\nimport { useActiveWeb3React } from './index'\nimport { useUnsupportedTokens } from './Tokens'\n\nfunction useAllCommonPairs(currencyA?: Token, currencyB?: Token): Pair[] {\n  const { chainId } = useActiveWeb3React()\n\n  const bases: Token[] = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : []\n  const [tokenA, tokenB] = [currencyA, currencyB]\n\n  const basePairs: [Token, Token][] = useMemo(\n    () =>\n      flatMap(bases, (base): [Token, Token][] => bases.map(otherBase => [base, otherBase])).filter(\n        ([t0, t1]) => t0.address !== t1.address\n      ),\n    [bases]\n  )\n\n  const allPairCombinations: [Token, Token][] = useMemo(\n    () =>\n      tokenA && tokenB\n        ? [\n            // the direct pair\n            [tokenA, tokenB],\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            // each base against all bases\n            ...basePairs\n          ]\n            .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n            .filter(([t0, t1]) => t0.address !== t1.address)\n        : [],\n    [tokenA, tokenB, bases, basePairs]\n  )\n\n  const allPairs = usePairs(allPairCombinations)\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\n            return memo\n          }, {})\n      ),\n    [allPairs]\n  )\n}\n\nconst MAX_HOPS = 3\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useTradeExactIn(currencyAmountIn?: TokenAmount, currencyOut?: Token): Trade | null {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut)\n\n  const [singleHopOnly] = useUserSingleHopOnly()\n\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        return (\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        )\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: Trade | null = null\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTrade: Trade | null =\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null\n        // if current trade is best yet, save it\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade\n        }\n      }\n      return bestTradeSoFar\n    }\n\n    return null\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly])\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useTradeExactOut(currencyIn?: Token, currencyAmountOut?: TokenAmount): Trade | null {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency)\n\n  const [singleHopOnly] = useUserSingleHopOnly()\n\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        return (\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        )\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: Trade | null = null\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTrade =\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade\n        }\n      }\n      return bestTradeSoFar\n    }\n    return null\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly])\n}\n\nexport function useIsTransactionUnsupported(currencyIn?: Token, currencyOut?: Token): boolean {\n  const unsupportedToken: { [address: string]: Token } = useUnsupportedTokens()\n\n  const tokenIn = currencyIn\n  const tokenOut = currencyOut\n\n  // if unsupported list loaded & either token on list, mark as unsupported\n  if (unsupportedToken) {\n    if (tokenIn && Object.keys(unsupportedToken).includes(tokenIn.address)) {\n      return true\n    }\n    if (tokenOut && Object.keys(unsupportedToken).includes(tokenOut.address)) {\n      return true\n    }\n  }\n\n  return false\n}\n"]},"metadata":{},"sourceType":"module"}